ambiguous_custom_block_signature=Los nombres de los bloques propios no son únicos. Solo se pueden distinguir dos bloques propios con el mismo nombre si tienen un número u orden de parámetros diferente. Trata de que los nombres de los bloques propios sean siempre únicos.
ambiguous_parameter_name_unused=Scratch permite múltiples parámetros con el mismo nombre en un bloque propio. Sin embargo, luego no puede distinguir entre estos parámetros, lo que causa problemas en tu programa. Utiliza siempre parámetros con nombres únicos.
ambiguous_parameter_name_used=Scratch permite múltiples parámetros con el mismo nombre en un bloque propio. Sin embargo, luego no puede distinguir entre estos parámetros, lo que causa problemas en tu programa. Utiliza siempre parámetros con nombres únicos.
blocking_if_else=Estás utilizando los bloques [sbi]detener [todos v][/sbi] o [sbi]detener [este programa v][/sbi] en la rama [IF] (si) y [ELSE] (entonces) de este bloque. Si lo haces así, el script terminará siempre y los bloques después de [sbi]si < > entonces[/sbi] nunca se ejecutan. Intenta utilizar mejor la instrucción de parada solo en una rama o elimina los bloques después de [sbi]si < > entonces[/sbi].
blocking_if_else_inside_loop=Estás utilizando los bloques [sbi]detener [todos v][/sbi] o [sbi]detener [este programa v][/sbi] en la rama [IF] (si) y [ELSE] (entonces) de este bloque. De esta manera, el script terminará siempre y las instrucciones fuera de [sbi]si < > entonces[/sbi] nunca se ejecutarán. Intenta usar el comando de parada solo en una rama o elimina el bucle.
busy_waiting_all=En tu secuencia de instrucciones, estás comprobando constantemente una condición, solo para detener todo una vez se cumpla. Utiliza mejor el bloque [sbi]espera hasta < >[/sbi] en lugar de la combinación forever (por siempre) e if (si) para finalizar tu script cuando se cumpla la condición.
busy_waiting_clone=En tu secuencia de instrucciones, estás comprobando constantemente una condición, solo para eliminar el clon una vez que se cumpla la condición. Mejor utiliza el bloque [sbi]espera hasta que < >[/sbi] en lugar de utilizar una combinación [sbi]por siempre[/sbi] e [sbi]si < > entonces[/sbi] para finalizar tu script cuando se cumpla la condición.
busy_waiting_script=En tu script, estás comprobando constantemente una condición, solo para detener el script una vez que se cumpla. Utiliza mejor el bloque [sbi]espera hasta que < >[/sbi] en lugar de la combinación [sbi]por siempre[/sbi] e [sbi]si < > entonces[/sbi] para finalizar tu script cuando se cumpla la condición.
call_without_definition=Si usaste un bloque propio en tu programa y lo eliminaste, todavía puede haber fragmentos de código que se refieran a este bloque propio. Asegúrate de eliminar todas las instancias en las que se utilizó el bloque propio eliminado.
clone_type_1=Hay insturcciones idénticas en varios guiones. Un bloque propio podría simplificar tu código.
clone_type_2=Hay instrucciones similares en varios scripts, que solo difieren en los parámetros. Un bloque personalizado podría simplificar tu código.
clone_type_3=Hay código similar en varios scripts. Un bloque personalizado podría simplificar tu código.
comparing_literals_default_false=Estás comparando dos valores que no cambian mientras se ejecuta tu programa. Tu bloque en forma de diamante siempre devolverá [FALSE]. En consecuencia, tu código entre corchetes horizontales %ALWAYSNEVER se ejecuta. Cambie la comparación por algo significativo o reemplace la estructura.
comparing_literals_default_true=Estás comparando dos valores que no cambian mientras se ejecuta tu programa. Tu bloque en forma de diamante siempre devolverá [VERDADERO]. En consecuencia, tu código entre corchetes horizontales %ALWAYSNEVER se ejecuta. Por lo tanto, el bloque es obsoleto.
comparing_literals_default_variable=Estás comparando dos valores que no cambian mientras se ejecuta tu programa. Tu bloque en forma de diamante siempre devolverá %TRUEFALSE%ADDINFODICT. En consecuencia, tu código entre corchetes horizontales %ALWAYSNEVER se ejecuta. ¿Prefieres utilizar una variable %VARIABLE? Si es así, debe ir a la paleta de variables y hacer una variable %VARIABLE primero. Luego, intente usar el nuevo bloque %VARIABLE en tu comparación.
comparing_literals_default_variable_exists=Estás comparando dos valores que no cambian mientras se ejecuta tu programa. Tu bloque en forma de diamante siempre devolverá %TRUEFALSE%ADDINFODICT. En consecuencia, tu código entre corchetes horizontales %ALWAYSNEVER se ejecuta. ¿Prefieres utilizar un bloque para tu variable definida %VARIABLE?
comparing_literals_default_variable_exists_two=Y como estás comparando dos valores que no cambian mientras se ejecuta tu programa, la comparación siempre resultará en %TRUEFALSE%ADDINFODICT. En consecuencia, tu código en el bloque [bc]%THENELSE[/bc] %ALWAYSNEVER se ejecutará. ¿Prefieres utilizar una variable [var]%VARIABLE1[/var] o una variable [var]%VARIABLE2[/var] o ambas? Si es así, debe ir a la caja de herramientas de variables y usar el bloque [var]%VARIABLE1[/var] y/o [var]%VARIABLE2[/var] en tu comparación.
comparing_literals_default_variable_exists_two_without_information=Y como estás comparando dos valores que no cambian mientras se ejecuta tu programa, la comparación siempre resultará en %TRUEFALSE%ADDINFODICT. ¿Prefieres utilizar una variable [var]%VARIABLE1[/var] o una variable [var]%VARIABLE2[/var] o ambas? Si es así, debe ir a la caja de herramientas de variables y usar el bloque [var]%VARIABLE1[/var] y/o [var]%VARIABLE2[/var] en tu comparación.
comparing_literals_default_variable_exists_without_information=Y como estás comparando dos valores que no cambian mientras se ejecuta tu programa, la comparación siempre resultará en %TRUEFALSE%ADDINFODICT. ¿Prefieres utilizar un bloque para tu variable definida [var]%VARIABLE[/var]?
comparing_literals_default_variable_two=Y como estás comparando dos valores que no cambian mientras se ejecuta tu programa, la comparación siempre resultará en %TRUEFALSE%ADDINFODICT. En consecuencia, tu código en el bloque [bc]%THENELSE[/bc] %ALWAYSNEVER se ejecutará. ¿Prefieres utilizar una variable [var]%VARIABLE1[/var] o una variable [var]%VARIABLE2[/var] o ambas? Si es así, tienes que ir a la caja de herramientas de variables y hacer una variable [var]%VARIABLE1[/var] o una variable [var]%VARIABLE2[/var] o ambas primero. Luego intenta usar el nuevo bloque [var]%VARIABLE1[/var] y/o [var]%VARIABLE2[/var] en tu comparación.
comparing_literals_default_variable_two_without_information=Y como estás comparando dos valores que no cambian mientras se ejecuta tu programa, la comparación siempre resultará en %TRUEFALSE%ADDINFODICT. ¿Prefieres utilizar una variable [var]%VARIABLE1[/var] o una variable [var]%VARIABLE2[/var] o ambas? Si es así, tienes que ir a la caja de herramientas de variables y hacer una variable [var]%VARIABLE1[/var] o una variable [var]%VARIABLE2[/var] o ambas primero. Luego intenta usar el nuevo bloque [var]%VARIABLE1[/var] y/o [var]%VARIABLE2[/var] en tu comparación.
comparing_literals_default_variable_without_information=Estás comparando dos valores que no cambian mientras se ejecuta tu programa. La comparación siempre resultará en %TRUEFALSE%ADDINFODICT. ¿Prefieres utilizar una variable [var]%VARIABLE[/var]? Si es así, debes ir a la caja de herramientas de variables y hacer una variable [var]%VARIABLE[/var] primero. Luego intenta usar el nuevo bloque [var]%VARIABLE[/var] en tu comparación.
comparing_literals_default_without_information=Estás comparando dos textos cuyos valores que no cambian durante la ejecución de tu programa. La comparación siempre resultará en %TRUEFALSE%ADDINFODICT. Cambia la comparación por algo significativo o modifica la estructura.
comparing_literals_wait_false=Estás comparando dos valores que no cambian mientras se ejecuta tu programa. Tu bloque en forma de diamante siempre devolverá FALSE. Los bloques después del bloque Wait se ejecutarán %ALWAYSNEVER. Cambia la comparación por algo significativo o reemplaza la estructura.
comparing_literals_wait_true=Estás comparando dos valores que no cambian mientras se ejecuta tu programa. Tu bloque en forma de diamante siempre devolverá VERDADERO. Los bloques después de Wait se ejecutarán %ALWAYSNEVER. Por lo tanto, el bloque es obsoleto.
comparing_literals_wait_variable=Estás comparando dos valores que no cambian mientras se ejecuta tu programa. Tu bloque en forma de diamante siempre devolverá %TRUEFALSE%ADDINFODICT. En consecuencia, los bloques después del bloque Wait se ejecutarán %ALWAYSNEVER. ¿Prefieres utilizar una variable %VARIABLE? Si es así, debes ir a la paleta de variables y hacer una variable %VARIABLE primero. Luego, intenta usar el nuevo bloque %VARIABLE en tu comparación.
comparing_literals_wait_variable_exists=Estás comparando dos valores que no cambian mientras se ejecuta tu programa. Tu bloque en forma de diamante siempre devolverá %TRUEFALSE%ADDINFODICT. En consecuencia, los bloques después del bloque Wait se ejecutarán %ALWAYSNEVER. ¿Prefieres utilizar un bloque para tu variable definida %VARIABLE?
comparing_literals_wait_variable_exists_two=Y como estás comparando dos valores que no cambian mientras se ejecuta tu programa, la comparación siempre resultará en %TRUEFALSE%ADDINFODICT. En consecuencia, tu código después del [sbi]espera hasta que el bloque < >[/sbi] %ALWAYSNEVER se ejecutará. ¿Prefieres utilizar la variable [var]%VARIABLE1[/var] o la variable [var]%VARIABLE2[/var] o ambas? Si es así, debes ir a la caja de herramientas de variables y usar el bloque [var]%VARIABLE1[/var] y/o [var]%VARIABLE2[/var] en tu comparación.
comparing_literals_wait_variable_two=Y como estás comparando dos valores que no cambian mientras se ejecuta tu programa, la comparación siempre resultará en %TRUEFALSE%ADDINFODICT. En consecuencia, tu código después de [sbi]espere hasta que <>[/sbi] %ALWAYSNEVER se ejecutará. ¿Prefieres utilizar una variable [var]%VARIABLE1[/var] o una variable [var]%VARIABLE2[/var] o ambas? Si es así, tienes que ir a la caja de herramientas de variables y hacer una variable [var]%VARIABLE1[/var] o una variable [var]%VARIABLE2[/var] o ambas primero. Luego intenta usar el nuevo bloque [var]%VARIABLE1[/var] y/o [var]%VARIABLE2[/var] en tu comparación.
custom_block_with_forever=Si un bloque propio contiene un bucle infinito y el bloque propio se usa en medio de otro script, el script nunca podrá finalizar. Un bloque forever en el bloque propio hace que el script que le llamó nunca pueda continuar.
custom_block_with_termination=The custom block [sbi]%METHOD[/sbi] contains a [sbi]stop [all v][/sbi] or [sbi]delete this clone[/sbi] and the custom block is called in the middle of another script, the script will never reach the blocks following the call of [sbi]%METHOD[/sbi]. Delete the [sbi]stop [all v][/sbi] or [sbi]delete this clone[/sbi] in the custom block [sbi]%METHOD[/sbi] or use an [sbi]if < > then[/sbi] block to not stop in every execution.
dead_code=Tu proyecto contiene bloques inaccesibles. Eso significa que hay bloques que nunca se ejecutarán. Esto hace que el proyecto esté desordenado. Puedes borrar estos bloques.
double_if=Tu proyecto contiene una condición [sbi]si < > entonces[/sbi] duplicada. Esto hace que el proyecto esté desordenado. Puedes acortar el programa fusionando las dos sentencias [sbi]si < > entonces[/sbi] en una única sentencia condicional.
duplicated_script=Tu proyecto contiene un script idéntico dos veces. Probablemente solo necesite uno de ellos y podrías eliminar la copia.
duplicate_sprite=Tu proyecto contiene varias copias exactas del mismo Sprite. Esto hace que el proyecto esté desordenado. Considera usar la clonación en su lugar.
empty_control_body=Los corchetes horizontales de [sbi]%BLOCKNAME[/sbi] están vacíos, por lo que cuando se invoca el bloque de control no sucede nada. Esto hace que tu código sea más difícil de entender. Considera eliminar este bloque si no lo necesitas.
empty_custom_block=Creaste un bloque propio que no contiene instrucciones. Cuando se invoca este bloque propio, no sucede nada. Considera eliminarlo si no lo necesitas.
empty_project=Tu proyecto está completamente vacío. Empieza agregando el primer sprite.
empty_script=Utilizas un bloque de eventos vacío, por lo que cuando ocurra el evento, no pasará nada. Elimina este bloque de eventos o agrega bloques después del mismo.
empty_sprite=El sprite %SPRITE no contiene bloques. No puede reaccionar a ninguna entrada de usuario o interacción con sprites. Si la intención es esa, déjalo como está. De lo contrario, debes pensar en lo que debería hacer el objeto e introducir scripts en este objeto.
endless_recursion_broadcast=Si un bloque propio se llama a sí mismo dentro de su cuerpo y no tiene ninguna condición para detener la recursividad, se ejecutará para siempre.
endless_recursion_procedure=Si se envía un mensaje en el mismo script en el que se recibió y el script no tiene ninguna condición para detener la recursividad, se ejecutará para siempre.
expression_as_touching_or_color=Este bloque espera un color o un sprite como parámetro y no funciona correctamente con una cadena o un número.
forever_inside_loop=Si dos bucles están anidados y el bucle interno es un bucle infinito, el bucle interno nunca terminará. Por lo tanto, las instrucciones después del bucle interno no se ejecutarán nunca.
illegal_parameter_refactor=El parámetro tiene un tipo incorrecto. Al editar el bloque propio, el parámetro booleano se ha convirtido en un parámetro numérico o de texto. Para arreglar esto, deshaz la edición.
immediate_delete_clone_after_broadcast=El script elimina el clon inmediatamente después del bloque [sbi]enviar (%MESSAGE v)[/sbi]. El script que maneja el mensaje para este clon no se ejecutará correctamente. En su lugar, es mejor usar un bloque de [sbi]enviar (%MESSAGE v) y esperar[/sbi].
immediate_stop_after_say_think=El script detiene todo inmediatamente después del bloque [bc]%SAYTHINK[/bc]. El texto nunca se llegará a mostrar. Reemplaza el bloque [bc]%SAYTHINK[/bc] por un bloque [sbi]%SAYTHINK durante ( ) segundos[/sbi].
inappropriate_handler_delete_clone=El script contiene un bloque de [sbi]eliminar este clon[/sbi]. Sin embargo,no se puede ejecutar porque en el controlador de eventos no Estás claro a qué clon te refieres. El script tiene que comenzar con un [sbi]al comenzar como clon[/sbi] o un [sbi]al hacer clic en este objeto[/sbi]. Otra posibilidad sería mover el bloque [sbi]eliminar este clon[/sbi] a un script que comience con uno de estos bloques.
interrupted_loop_sensing=El bloque [bc]%BLOCKNAME[/bc] interrumpe la comprobación de la condición del bloque [bc]%THENELSE[/bc] mientras se ejecuta. Puede suceder que se produzca la condición, pero tu script no reacciona en consecuencia porque Estás ocupado haciendo el bloque [bc]%BLOCKNAME[/bc]. Considera realizar la verificación de la condición en un script separado (paralelo).
long_script=El script que has creado es muy largo. Divídelo en dos o más scripts más pequeños para mantener la perspectiva de lo que estás haciendo.
loop_one=Si establece el número de repeticiones de un bucle en 1, se ejecutará una sola vez. En ese caso, se podría eliminar el bloque de bucle y simplemente conectar los bloques que contiene.
loop_zero=Si estableces el número de repeticiones de un bucle en 0, nunca se ejecutará. En ese caso, se podría quitar el bloque de bucle y los bloques que contiene.
message_naming=El mensaje [bc]%MESSAGE[/bc] no tiene un nombre con sentido. Estás utilizando el nombre por defecto o uno que ya está en uso seguido por un número. Esto hace que tu programa sea difícil de comprender. Utiliza un mensaje con sentido y único.
message_never_received=El mensaje %MESSAGE enviado por esta transmisión nunca es recibido por ningún bloque [sbi]al recibir [ v][/sbi]. De modo que no ocurrirá nada como reacción al mensaje. Cuando un script envía un mensaje, hay que comprobar que lo reciba otro script.
message_never_sent=El mensaje %MESSAGE que debe recibir este bloque nunca se envía. Por tanto, este script nunca se activará. Cuando un script espera recibir un mensaje, hay que comprobar que otro script se lo envíe.
message_never_sent_say_think=El mensaje [bc]%MESSAGE[/bc] que debería recibir este bloque nunca se envía. Este script nunca se activará. Estás utilizando el mensaje como texto en un bloque [sbi]%SAYTHINK durante ( ) segundos[/sbi] para el/los sprite(s): %SPRITE. Piensa si quieres enviar un mensaje [sbi]enviar [%MESSAGE v][/sbi] para avisarles.
message_never_sent_touching=El mensaje [bc]%MESSAGE[/bc] que debería recibir este bloque nunca se envía. Este script nunca se activará. Estás utilizando un bloque [sbi]tocando (%SPRITE v)?[/sbi] en %SPRITE. Si quieres enviar un mensaje sobre el evento de haberse tocado a todos los sprites, debes usar un bloque de transmisión [sbi]enviar (%MESSAGE v)[/sbi].
middle_man_broadcast=Usar un receptor de transmisión solo para enviar una transmisión nuevamente se considera un mal olor en el código, ya que el script es un intermediario entre el remitente original y el receptor final. Considera cambiar el códig para que el mensaje llegue al receptor final en la primera transmisión, y luego elimina el intermediario para que no haya código redundante.
middle_man_procedure=El uso de un bloque propio solo para llamar a otro bloque propio se considera un mal olor en el código, ya que el primer bloque propio es un intermediario. Considera cambiar la llamada al primer bloque propio convirtiéndola en una llamada al bloque propio final, y luego elimina el intermediario para que no haya código redundante.
missing_ask=Tu proyecto usa el bloque [sbi]respuesta[/sbi], pero el bloque [sbi]preguntar () y esperar[/sbi] nunca se usa en el proyecto. El bloque [sbi]respuesta[/sbi] no puede devolver un valor con sentido. Utiliza el bloque [sbi]preguntar () y esperar[/sbi] antes de la primera instancia de [sbi]respuesta[/sbi].
missing_backdrop_switch=Si el bloque [sbi]Cuando el fondo cambie a [ v][/sbi] se usa para iniciar un script y el fondo nunca cambia al fondo seleccionado, el script nunca se ejecuta. Asegúrate de cambiar el fondo de tu proyecto.
missing_clone_call=Si el bloque [sbi]al comenzar como clon[/sbi] se usa para iniciar un script, pero el sprite nunca se clona, el evento nunca se activará y el script no se ejecutará. Asegúrate de usar un bloque de clonación.
missing_clone_initialization=Cuando se clona un objeto, pero este no tiene secuencias de comandos iniciadas por los eventos [sbi]al comenzar como clon[/sbi] o [sbi]al hacer clic en este objeto[/sbi], los clones no realizarán ninguna acción. Quizás quieras usar un controlador de eventos en tu proyecto. De lo contrario, puedes usar el bloque [sbi]sellar[/sbi] en la extensión del lápiz si el clon solo debe ser visible.
missing_clone_initialization_delete_clone=Cuando un sprite es clonado pero no tiene scripts iniciados por [sbi]al comenzar como clon[/sbi] o [sbi]al hacer clic en este objeto[/sbi], los clones no realizarán ninguna acción. Quizás quieras utilizar uno de estos dos controladores de eventos en tu proyecto. Además, estás utilizando un [sbi]eliminar este clon[/sbi] en un script de %SPRITE. Considera iniciar este script con un [sbi]al comenzar como clon[/sbi] o [sbi]al hacer clic en este objeto[/sbi].
missing_clone_initialization_delete_clone_message=Cuando un sprite es clonado pero no tiene scripts iniciados por [sbi]al comenzar como clon[/sbi] o [sbi]al hacer clic en este objeto[/sbi], los clones no realizarán ninguna acción. Quizás quieras utilizar uno de estos dos controladores de eventos en tu proyecto. Además, estás utilizando un [sbi]eliminar este clon[/sbi] en un script de %SPRITE que comienza con el mensaje [bc]%MESSAGE[/bc]. Busca en el sprite %SPRITE el script que envía el mensaje [bc]%MESSAGE[/bc]. Considera comenzar ese script con un [sbi]al comenzar como clon[/sbi] o [sbi]al hacer clic en este objeto[/sbi] en lugar de con un bloque [bc]%EVENTHANDLER[/bc].
missing_clone_initialization_delete_clone_message_multiple=Cuando un sprite es clonado pero no tiene scripts iniciados por [sbi]Cuando comienzo como un clon[/sbi] o [sbi]Cuando este sprite hace clic en los eventos[/sbi], los clones no realizarán ninguna acción. Quizás quieras utilizar uno de estos dos controladores de eventos en tu proyecto. Además, estás utilizando un [sbi]eliminar este clon[/sbi] en un script de %SPRITE que comienza con el mensaje [bc]%MESSAGE[/bc]. Busca en el sprite %SPRITE los scripts que envían el mensaje [bc]%MESSAGE[/bc]. Considera comenzar esos scripts con un [sbi]al comenzar como clon[/sbi] o [sbi]al hacer clic en este objeto[/sbi] en lugar de con bloques [bc]%EVENTHANDLER[/bc].
missing_erase_all=Si un objeto usa un bloque de lápiz hacia abajo pero nunca un bloque para borrar todo, todos los dibujos de una ejecución anterior permanecen para la siguiente ejecución. Tal vez deberías usar un bloque [sbi]detener [todos][/sbi] después de tu bloque de inicio.
missing_initialization=En este sprite, %VARIABLE no se inicializa antes de ser utilizado por primera vez. Utilizará cualquier valor que contenga al final de la última ejecución, lo que puede que no sea lo que quieras.
missing_initialization_clone=En este sprite, %VARIABLE no se inicializa antes de ser utilizado por primera vez. Lo que puede que no sea lo que quieras.
missing_loop_sensing=Tu script ha de ejecutar acciones cuando ocurra un evento. Para ello, el script ha de estar continuamente verificando si el evento ha sucedido para no perdérselo.
missing_loop_sensing_variable=Si estás esperando a que una variable tenga un valor específico, tienes que verificar ese evento continuamente dentro de un bucle, porque si no, no te enterarás del evento. Utiliza un bloque de repetición.
missing_pen_down=Usas el bloque [sbi]bajar lápiz[/sbi] pero nunca vuelves a levantar el lápiz, por lo que tu sprite dibujará para siempre. Asegúrate de usar un bloque de [sbi]subir lápiz[/sbi] en el sprite.
missing_pen_up=Usas el bloque [sbi]subir lápiz[/sbi] pero tu sprite nunca ha bajado el bolígrafo antes. Asegúrate de usar un bloque de [sbi]bajar lápiz[/sbi] si quieres dibujar algo.
missing_resource=A tu programa le falta el sonido o la imagen que estás intentando utilizar. Seleccione otro sonido o imagen o agrega la que desees usar.
missing_termination=El bloque [sbi]repetir hasta que < >[/sbi] requiere una condición de parada. Si falta esa condición, el resultado es un bucle infinito. Si tienes  un bucle infinito no se ejecutarán los bloques posteriores.
missing_wait_condition=El bloque [sbi]espera hasta que < >[/sbi] requiere una condición. Si falta esa condición, el bloque esperará eternamente y el código que lo sigue nunca se ejecutará.
multiple_attribute_modifications=Hay varios cambios de la misma variable o atributo uno detrás de otro, que podrían ser reemplazados por una única instrucción.
nested_loops=Si se anidan dos o más bucles, a menudo se producen problemas impredecibles. Evita hacerlo.
no_working_scripts=Tu sprite solo tiene bloques de sombrero (de inicio) sueltos y otros bloques muertos. Asegúrate de conectar los bloques de sombrero a los otros bloques para que el objeto pueda reaccionar a los eventos.
orphaned_parameter=Si eliminas un parámetro de un bloque propio, asegúrate de eliminarlo de todas las ubicaciones donde lo usaste antes.
parameter_out_of_scope=Asegúrate de utilizar los parámetros de un bloque propio solo dentro de ese bloque.
position_equals_check_dist=La posición de un objeto normalmente se define por su centro. Es poco probable que la distancia entre dos objetos tenga el valor exacto en una comparación. En su lugar, intenta utilizar una aproximación con [LEQ] o [GEQ].
position_equals_check=La posición de un objeto normalmente se define por su centro. Es poco probable que la coordenada %COORDINATE de un objeto tenga el valor exacto en una comparación. En su lugar, intenta utilizar una aproximación con [LEQ] o [GEQ].
position_equals_check_zero_mouse=La distancia entre un sprite y el puntero del ratón generalmente se mide de centro a centro. Es poco probable que los puntos centrales del puntero del ratón y el sprite estén exactamente uno encima del otro. Por eso, elimine la igualdad [EQ] y en su lubar usa una aproximación con [LEQ] o usa el bloque en forma de diamante [sbi]¿tocando ( v)?[/sbi].
position_equals_check_zero_sprites=La distancia entre dos sprites generalmente se mide de centro a centro. Es muy poco probable que los centros de dos sprites estén exactamente uno encima del otro. Modifica la igualdad [EQ] y en su lugar usa una aproximación con [LEQ] o usa el bloque en forma de diamante [sbi]¿tocando ( v)?[/sbi].
recursive_cloning=Los scripts que comienzan con [sbi]al comenzar como clon[/sbi] no deberían crear clones de sí mismos. Esto podría resultar en un número infinito de clones.
same_variable_different_sprite=El mismo nombre de variable se usa en múltiples sprites. Esto puede resultar confuso. Asegúrate de utilizar nombres únicos para tus variables.
sequential_actions=Tu programa contiene una secuencia de instrucciones similares repetidas que probablemente puedan acortarse mediante un bucle.
sprite_naming=El sprite %SPRITE no tiene un nombre significativo, ya que utiliza el nombre predeterminado o uno que ya se utiliza seguido de un número. Esto hace que tu programa sea difícil de entender. Dale al sprite un nombre significativo y único.
stuttering_movement=Cuando usas el evento [sbi]al presionar tecla [ v][/sbi] para el movimiento, esto podría resultar en un movimiento entrecortado. En este caso, es mejor usar un bucle [sbi]por siempre[/sbi] que maneje los eventos de pulsación de teclas.
terminated_loop=El bucle finaliza antes de que realmente se repita (por ejemplo, mediante un bloque de parada).
type_error=Algunas de las comparaciones comparan atributos de diferentes tipos.
type_error_weird_distance=Estás utilizando un bloque de [sbi]distancia a (v)[/sbi] en una situación donde no puedes medir la distancia. Usa el puntero del ratón o las opciones de nombre de sprite que te da la distancia [sbi]distancia a ( v)[/sbi].
unnecessary_if_after_until=Estás utilizando un bloque [sbi]si < >, entonces[/sbi] después de un bloque [sbi]repetir hasta que < >[/sbi] con la misma condición. Los bloques dentro del [sbi]si < >, entonces[/sbi] se ejecutarán siempre. Puedes, por tanto, borrar el bloque [sbi]si < >, entonces[/sbi].
unnecessary_if_after_until_else=Estás utilizando un bloque [sbi]si < >, entonces si no[/sbi] después de un bloque [sbi]repetir hasta que < >[/sbi] con la misma condición. Los bloques dentro del [sbi]si < >, entonces si no[/sbi] se ejecutarán siempre. Puedes, por tanto, borrar el bloque [sbi]si < >, entonces si no[/sbi].
unnecessary_glide=You are using a [sbi]glide ( ) secs. to ( v))[/sbi] block. Since the time value is 0 this block is executed immediately. You can use a [sbi]go to ( v))[/sbi] block instead.
unnecessary_glide_xy=You are using a [sbi]glide ( ) secs. to x: ( ) y: ( ))[/sbi] block. Since the time value is 0 this block is executed immediately. You can use a [sbi]go to x: ( ) y: ( )[/sbi] block instead.
unnecessary_say=You are using a [sbi]say ( ) for ( ) seconds[/sbi] block. Since the time value is 0 this block has no effect. You can delete it.
unnecessary_think=You are using a [sbi]think ( ) for ( ) seconds[/sbi] block. Since the time value is 0 this block has no effect. You can delete it.
unnecessary_wait=You are using a [sbi]wait ( ) seconds[/sbi] block. Since the value is 0 this block has no effect. You can delete it.
unused_custom_block=Has creado un bloque propio pero nunca lo usas en tu proyecto. Esto hace que el proyecto esté desordenado. Elimina el bloque propio.
unused_parameter=Has creado un parámetro pero nunca lo usas en tu procedimiento. Esto hace que el bloque propio sea más difícil de entender. Elimina el parámetro.
unused_variables=Has creado una variable [var]%VARIABLE[/var] pero nunca la usas en tu proyecto. Esto hace que el proyecto sea más difícil de entender. Borra la variable [var]%VARIABLE[/var] o usa los bloques [sbi]dar a [%VARIABLE v] el valor ( )[/sbi], [sbi]sumar a [%VARIABLE v] ( )[/sbi] en tu proyecto.
unused_variables_list=Has creado una variable de tipo lista [var]%VARIABLE[/var], pero nunca la utilizas en tu proyecto. Esto hace que tu código sea más difícil de entender. Borra la variable de tipo lista [var]%VARIABLE[/var] o usa los bloques [sbi]sumar a [%VARIABLE v] ( )[/sbi], [sbi]dar a [%VARIABLE v] el valor ( )[/sbi] en tu proyecto.
variable_as_literal=Estás usando el nombre de una variable como texto. ¿No será que lo que quieres hacer es utilizar el bloque  %VARIABLE en su lugar?
variable_initialization_race=Una variable se inicializa en diferentes scripts activados por el mismo evento. El resultado puede cambiar según el orden en que se ejecuten los scripts. Intenta asignar los valores en solo uno de los scripts.
valid_termination=Termination in UntilStmt
list_usage=used list
loop_sensing=sensing_in_loop
matching_parameter=initialized_parameter
correct_broadcast=correct_broadcast
useful_position_check=useful_position_check
movement_in_loop=movement_in_loop
custom_block_usage=custom_block_usage
boolean_expression=boolean_expression
initialisation_of_position=initialize_location
parallelisation=parallelisation
coordination=coordination
directed_motion=directed_motion
collision=collision
gliding_motion=gliding_motion
mouse_follower=mouse_follower
object_follower=object_follower
timer=timer
initialisation_of_looks_sprite=Super! You initialize the looks of your sprite with every new program start.
initialisation_of_looks_stage=Super! You initialize the looks of your stage with every new program start.
nested_conditional_checks=nested_conditional_checks
nested_loops_perfume=nested_loops_perfume
conditional_inside_loop=condition_in_loop
say_sound_synchronisation=say_sound_synchronization
controlled_broadcast_or_stop=ControlledBroadcastOrStop
backdrop_switch=Very nice! You use the backdrop change event to start different scipts. That allows you to perform different actions depending on the backdrop of the game.
